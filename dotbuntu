#!/usr/bin/env bash
#######################################
# dotbuntu - Unified system configuration and dotfiles management tool
#
# Consolidated tool for professional Git setup and dotfiles management.
# Combines functionality from gitconfig (Git/SSH/GPG configuration) and
# dotmarchy (dotfiles and package management).
#
# Usage:
#   ./dotbuntu [options] [REPO_URL]
#
# Options:
#   --non-interactive    Run without user prompts
#   --auto-upload        Automatically upload keys to GitHub
#   --extras             Install extra packages (npm, cargo, etc.)
#   --setup-env          Setup environment (dirs, repos, shell)
#   --verify             Run verification checks
#   --repo URL           Override default dotfiles repository
#   -v, --verbose        Enable verbose output
#   -f, --force          Force operations without prompts
#   --help, -h           Show help information
#
# @author: dotbuntu
# @version: 1.0.0
#######################################

set -Eeuo pipefail

#######################################
# Script Location
#
# Determine script directory, resolving symlinks for reliable path resolution.
#######################################
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export SCRIPT_DIR

#######################################
# Module Loading
#
# Source all required modules in dependency order:
# 1. Configuration (defaults.sh)
# 2. Core utilities (colors, logger, validation, ui, common)
# 3. Helper modules (via dynamic loader)
# 4. Feature modules (dependencies, ssh, gpg, git-config, github, finalize)
#######################################

# Source configuration defaults (consolidated)
# shellcheck source=config/defaults.sh
source "${SCRIPT_DIR}/config/defaults.sh"

# Source core modules (from gitconfig)
# shellcheck source=scripts/core/colors.sh
source "${SCRIPT_DIR}/scripts/core/colors.sh"
# shellcheck source=scripts/core/logger.sh
source "${SCRIPT_DIR}/scripts/core/logger.sh"
# shellcheck source=scripts/core/validation.sh
source "${SCRIPT_DIR}/scripts/core/validation.sh"
# shellcheck source=scripts/core/ui.sh
source "${SCRIPT_DIR}/scripts/core/ui.sh"
# shellcheck source=scripts/core/common.sh
source "${SCRIPT_DIR}/scripts/core/common.sh"

# Source dotmarchy helpers via dynamic loader
# shellcheck source=helper/load_helpers.sh
source "${SCRIPT_DIR}/helper/load_helpers.sh"
load_helpers "${SCRIPT_DIR}/helper" utils checks prompts

# Source feature modules (from gitconfig)
# shellcheck source=scripts/dependencies.sh
source "${SCRIPT_DIR}/scripts/dependencies.sh"
# shellcheck source=scripts/ssh.sh
source "${SCRIPT_DIR}/scripts/ssh.sh"
# shellcheck source=scripts/gpg.sh
source "${SCRIPT_DIR}/scripts/gpg.sh"
# shellcheck source=scripts/git-config.sh
source "${SCRIPT_DIR}/scripts/git-config.sh"
# shellcheck source=scripts/github.sh
source "${SCRIPT_DIR}/scripts/github.sh"
# shellcheck source=scripts/finalize.sh
source "${SCRIPT_DIR}/scripts/finalize.sh"

#######################################
# Display help information
#
# Shows usage, options, and examples for the dotbuntu tool.
#
# Globals:
#   COLORS - Associative array of color codes (from defaults.sh)
#   DOTBUNTU_VERSION - Version string (from defaults.sh)
#
# Returns:
#   0 - Always succeeds
#
# Outputs:
#   STDOUT - Help text with color formatting
#######################################
show_help() {
    printf "%b\n" "${COLORS[bold]}${COLORS[primary]}dotbuntu${COLORS[reset]} ${DOTBUNTU_VERSION}"
    printf "%b\n" "Unified system configuration and dotfiles management tool"
    printf "\n"
    printf "%b\n" "${COLORS[bold]}Usage:${COLORS[reset]}"
    printf "%b\n" "  ${0##*/} [OPTIONS] [REPO_URL]"
    printf "\n"
    printf "%b\n" "${COLORS[bold]}Options:${COLORS[reset]}"
    printf "%b\n" "  -h, --help          Show this help message and exit"
    printf "%b\n" "  --non-interactive   Run Git configuration without prompts"
    printf "%b\n" "  --auto-upload       Automatically upload keys to GitHub"
    printf "%b\n" "  --extras            Install extra packages"
    printf "%b\n" "  --legacy            Use legacy package managers (DEPRECATED, use before 2026-03)"
    printf "%b\n" "  --setup-env         Setup environment (directories, repos, shell config)"
    printf "%b\n" "  --verify            Run verification checks and exit"
    printf "%b\n" "  --repo URL          Override default dotfiles repository URL"
    printf "%b\n" "  -v, --verbose       Enable verbose output"
    printf "%b\n" ""
    printf "%b\n" "${COLORS[bold]}Package Management:${COLORS[reset]}"
    printf "%b\n" "  By default, packages are managed via NIX (reproducible, cross-platform)"
    printf "%b\n" "  Use --legacy for old apt/pacman/AUR method (deprecated)"
    printf "%b\n" "  See docs/NIX_SETUP.md and docs/MIGRATION.md for details"
    printf "%b\n" "  -f, --force         Force operations without prompts"
    printf "\n"
    printf "%b\n" "${COLORS[bold]}Examples:${COLORS[reset]}"
    printf "%b\n" "  ${0##*/}                            # Standard Git & Core setup"
    printf "%b\n" "  ${0##*/} --extras --setup-env       # Full dev environment setup"
    printf "%b\n" "  ${0##*/} --repo git@github.com:u/d.git"
    printf "%b\n" "  ${0##*/} --verify                   # Run diagnostics"
}

#######################################
# Parse command-line arguments
#
# Processes all CLI flags and sets corresponding global variables.
# Exits with appropriate code for invalid input or help request.
#
# Globals:
#   INTERACTIVE_MODE - Set to false with --non-interactive
#   AUTO_UPLOAD_KEYS - Set to true with --auto-upload
#   INSTALL_EXTRAS - Set to 1 with --extras
#   SETUP_ENVIRONMENT - Set to 1 with --setup-env
#   VERIFY_MODE - Set to 1 with --verify
#   REPO_URL - Set with --repo or positional argument
#   VERBOSE - Set to 1 with -v/--verbose
#   FORCE - Set to 1 with -f/--force
#
# Arguments:
#   $@ - Command-line arguments
#
# Returns:
#   0 - Arguments parsed successfully
#
# Outputs:
#   STDERR - Error messages for invalid options
#
# Side Effects:
#   Exits with code 0 for --help
#   Exits with code 1 for unknown options
#   Exits with code 2 for missing required argument
#######################################
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --non-interactive)
                INTERACTIVE_MODE=false
                shift
                ;;
            --auto-upload)
                AUTO_UPLOAD_KEYS=true
                shift
                ;;
            --extras)
                export INSTALL_EXTRAS=1
                shift
                ;;
            --setup-env)
                export SETUP_ENVIRONMENT=1
                shift
                ;;
            --verify)
                export VERIFY_MODE=1
                shift
                ;;
            --legacy)
                export USE_LEGACY=1
                export USE_NIX=0
                shift
                ;;
            --repo)
                [[ -z "${2:-}" ]] && { error "Opción --repo requiere un argumento"; exit 2; }
                export REPO_URL="$2"
                shift 2
                ;;
            -v|--verbose)
                export VERBOSE=1
                shift
                ;;
            -f|--force)
                export FORCE=1
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            -*)
                error "Opción desconocida: $1"
                echo "Usa --help para ver opciones disponibles"
                exit 1
                ;;
            *)
                export REPO_URL="$1"
                shift
                ;;
        esac
    done
}

#######################################
# Execute NIX-based package management
#
# Installs NIX if needed and syncs packages from packages.nix.
# This is the NIX alternative to execute_core_operations.
# Automatically ensures NIX is in PATH before operations.
#
# Globals:
#   SCRIPT_DIR - Directory containing this script
#
# Returns:
#   0 - Success
#   1 - Failure
#######################################
execute_nix_operations() {
    info "Usando NIX para gestión de paquetes..."
    
    # Source NIX helpers
    # shellcheck source=helper/nix-helpers.sh
    source "${SCRIPT_DIR}/helper/nix-helpers.sh"
    
    # Check if NIX is installed and load into PATH if needed
    if ! nix_is_installed; then
        info "NIX no detectado, iniciando instalación..."
        "${SCRIPT_DIR}/scripts/bootstrap-nix.sh" || {
            error "Instalación de NIX fallida"
            return 1
        }
        
        # After installation, ensure NIX is in PATH
        if ! nix_ensure_in_path; then
            error "NIX instalado pero no se pudo cargar en PATH"
            info "Intenta reiniciar tu shell o ejecuta:"
            echo "  source /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh"
            return 1
        fi
    else
        local version
        version=$(nix_get_version)
        success "NIX ya instalado: $version"
    fi
    
    # Sync packages from packages.nix
    info "Sincronizando paquetes desde packages.nix..."
    "${SCRIPT_DIR}/scripts/sync-packages.sh" || {
        warn "Algunos paquetes pueden no haberse instalado correctamente"
        warn "Revisa el log para más detalles"
        return 1
    }
    
    success "Paquetes NIX sincronizados exitosamente"
}

#######################################
# Main orchestration function
#
# Coordinates the two-phase execution flow:
# Phase 1: Dotfiles & System Setup (dotmarchy functionality)
# Phase 2: Git & GitHub Professional Setup (gitconfig functionality)
#
# Globals:
#   INTERACTIVE_MODE - Controls whether to prompt user
#   VERIFY_MODE - If 1, run verification and exit
#   INSTALL_EXTRAS - If 1, install extra packages
#   SETUP_ENVIRONMENT - If 1, setup development environment
#   AUTO_UPLOAD_KEYS - If true, auto-upload keys to GitHub
#   SCRIPT_DIR - Directory containing this script
#   DOTMARCHY_ERROR_LOG - Path to error log file
#
# Arguments:
#   $@ - Command-line arguments (passed to parse_arguments)
#
# Returns:
#   0 - Success
#   1 - Failure
#
# Outputs:
#   STDOUT - Progress messages and prompts
#   STDERR - Error messages
#######################################
main() {
    # Parse command-line arguments
    parse_arguments "$@"
    
    # Initialize dotmarchy error log
    if [[ -n "${DOTMARCHY_ERROR_LOG:-}" ]]; then
        mkdir -p "$(dirname "${DOTMARCHY_ERROR_LOG}")" 2>/dev/null || true
        : > "${DOTMARCHY_ERROR_LOG}"
    fi

    # Handle verification mode
    if [[ "${VERIFY_MODE:-0}" -eq 1 ]]; then
        info "Iniciando modo de verificación..."
        exec "${SCRIPT_DIR}/scripts/fverify"
    fi

    # Perform initial checks
    initial_checks
    welcome # This shows the logo and welcome message
    
    #==========================================================================
    # PHASE 1: DOTFILES & SYSTEM SETUP (DOTMARCHY)
    #==========================================================================
    local DOTMARCHY_PROCEED=0
    if [[ "$INTERACTIVE_MODE" == "true" ]]; then
        if ask_yes_no "¿Deseas proceder con la instalación de dotfiles y paquetes del sistema?" "y"; then
            DOTMARCHY_PROCEED=1
        fi
    else
        # In non-interactive mode, only proceed if flags are set
        if [[ "${INSTALL_EXTRAS:-0}" -eq 1 ]] || [[ "${SETUP_ENVIRONMENT:-0}" -eq 1 ]]; then
            DOTMARCHY_PROCEED=1
        fi
    fi

    if [[ "$DOTMARCHY_PROCEED" -eq 1 ]]; then
        # Basic checks (not root, internet) - always needed
        verify_not_root
        verify_internet_connection
        
        # Detect OS for package management
        local os_type
        os_type=$(detect_os)
        info "Sistema operativo detectado: $os_type"
        
        # Show dotmarchy specific welcome and summary
        show_welcome
        
        # Phase 1.1: Dotbare (doesn't require specific distro)
        configure_dotbare
        
        # Phase 1.2: Core Operations (package installation)
        # Check if we have a supported package manager
        local can_install_packages=false
        case "$os_type" in
            arch|manjaro|endeavouros|garuda)
                if command -v pacman >/dev/null 2>&1; then
                    can_install_packages=true
                    info "Gestor de paquetes: pacman (Arch Linux)"
                fi
                ;;
            ubuntu|debian|linuxmint|pop|elementary)
                if command -v apt >/dev/null 2>&1; then
                    can_install_packages=true
                    info "Gestor de paquetes: apt (Debian/Ubuntu)"
                fi
                ;;
            fedora|rhel|centos|rocky|alma)
                if command -v dnf >/dev/null 2>&1 || command -v yum >/dev/null 2>&1; then
                    can_install_packages=true
                    info "Gestor de paquetes: dnf/yum (Fedora/RHEL)"
                fi
                ;;
            darwin)
                if command -v brew >/dev/null 2>&1; then
                    can_install_packages=true
                    info "Gestor de paquetes: Homebrew (macOS)"
                fi
                ;;
        esac
        
        # Check if using legacy mode (deprecated)
        if [[ "${USE_LEGACY:-0}" -eq 1 ]]; then
            warn "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            warn "  LEGACY MODE (DEPRECATED)"
            warn "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            warn "You are using the legacy package management system."
            warn "This will be removed on 2026-03-01 (3 months from v2.0.0 release)"
            warn ""
            warn "Migration guide: ${SCRIPT_DIR}/docs/MIGRATION.md"
            warn "NIX setup guide: ${SCRIPT_DIR}/docs/NIX_SETUP.md"
            warn "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            sleep 3
            
            if [[ "$can_install_packages" == true ]]; then
                execute_core_operations
            else
                error "No supported package manager found for legacy mode"
                return 1
            fi
        elif [[ "${USE_NIX:-1}" -eq 1 ]]; then
            # NIX is now the default
            execute_nix_operations || {
                error "NIX package management failed"
                info "Tip: Use --legacy flag to use old package managers (deprecated)"
                return 1
            }
        else
            warn "Instalación de paquetes del sistema no disponible"
            info "Sistema: $os_type"
            info "Usa ./install.sh o ./dotbuntu para instalar paquetes"
            info "  • Ubuntu/Debian (apt) - en desarrollo"
            info "  • Fedora/RHEL (dnf/yum) - en desarrollo"
            info "  • macOS (brew) - en desarrollo"
            info ""
            info "Puedes continuar con dotbare y configuración de Git"
        fi
        
        # Phase 1.3: Extras (requires package manager for some operations)
        if [[ "${INSTALL_EXTRAS:-0}" -eq 1 ]]; then
            if [[ "$can_install_packages" == true ]]; then
                execute_extras_operations
            else
                warn "Saltando instalación de extras (gestor de paquetes no soportado)"
            fi
        fi
        
        # Phase 1.4: Environment Setup (doesn't require specific distro)
        if [[ "${SETUP_ENVIRONMENT:-0}" -eq 1 ]]; then
            execute_setup_operations
        fi
        
        show_farewell
    fi

    #==========================================================================
    # PHASE 2: GIT & GITHUB PROFESSIONAL SETUP
    #==========================================================================
    if [[ "$INTERACTIVE_MODE" == "true" ]] && ask_yes_no "¿Deseas configurar Git, SSH y GPG de forma profesional?" "y"; then
        log "=== INICIO DE CONFIGURACIÓN DE GIT ==="
        
        # Early GitHub CLI check
        if [[ "$AUTO_UPLOAD_KEYS" == "true" ]]; then
            if ! ensure_github_cli_ready "early"; then
                exit 1
            fi
        fi
        
        # Initialize progress variables
        TOTAL_STEPS=9
        CURRENT_STEP=0
        
        # Dependency check
        CURRENT_STEP=$((CURRENT_STEP + 1))
        show_progress_bar $CURRENT_STEP $TOTAL_STEPS "${WORKFLOW_STEPS[$CURRENT_STEP]}"
        check_dependencies
        
        # Setup directories
        CURRENT_STEP=$((CURRENT_STEP + 1))
        show_progress_bar $CURRENT_STEP $TOTAL_STEPS "${WORKFLOW_STEPS[$CURRENT_STEP]}"
        setup_directories
        
        # Backup keys
        CURRENT_STEP=$((CURRENT_STEP + 1))
        show_progress_bar $CURRENT_STEP $TOTAL_STEPS "${WORKFLOW_STEPS[$CURRENT_STEP]}"
        backup_existing_keys
        
        # User info
        CURRENT_STEP=$((CURRENT_STEP + 1))
        show_progress_bar $CURRENT_STEP $TOTAL_STEPS "${WORKFLOW_STEPS[$CURRENT_STEP]}"
        collect_user_info
        
        # GPG logic
        if [[ -z "${GENERATE_GPG:-}" || "$GENERATE_GPG" == "false" ]]; then
            if ask_yes_no "¿Deseas generar también una llave GPG para firmar commits?" "n"; then
                GENERATE_GPG="true"
            fi
        fi
        
        # Summary
        show_changes_summary
        
        # SSH
        CURRENT_STEP=$((CURRENT_STEP + 1))
        show_progress_bar $CURRENT_STEP $TOTAL_STEPS "${WORKFLOW_STEPS[$CURRENT_STEP]}"
        generate_ssh_key
        
        # GPG
        if [[ "$GENERATE_GPG" == "true" ]]; then
            CURRENT_STEP=$((CURRENT_STEP + 1))
            show_progress_bar $CURRENT_STEP $TOTAL_STEPS "${WORKFLOW_STEPS[$CURRENT_STEP]}"
            generate_gpg_key
        fi
        
        # Git Config
        CURRENT_STEP=$((CURRENT_STEP + 1))
        show_progress_bar $CURRENT_STEP $TOTAL_STEPS "${WORKFLOW_STEPS[$CURRENT_STEP]}"
        configure_git
        
        # Agent
        CURRENT_STEP=$((CURRENT_STEP + 1))
        show_progress_bar $CURRENT_STEP $TOTAL_STEPS "${WORKFLOW_STEPS[$CURRENT_STEP]}"
        create_ssh_agent_script
        
        # Display/Upload
        display_keys
        maybe_upload_keys
        
        # Final Instructions for Phase 2
        CURRENT_STEP=$((CURRENT_STEP + 1))
        show_progress_bar $CURRENT_STEP $TOTAL_STEPS "${WORKFLOW_STEPS[$CURRENT_STEP]}"
        show_final_instructions
        
        success "Configuración de Git completada."
    fi
    
    log "=== FIN DE SESIÓN EXITOSA ==="
    echo ""
    success "¡Dotbuntu completado exitosamente!"
}

#######################################
# Handle interrupt signals
#
# Cleanup function triggered by SIGINT (Ctrl+C) or SIGTERM.
# Displays user-friendly message and exits with code 130.
#
# Returns:
#   130 - Standard exit code for SIGINT
#
# Outputs:
#   STDOUT - Blank line for formatting
#   STDOUT - Warning message about interruption
#######################################
cleanup() {
    echo ""
    warning "Script interrumpido por el usuario"
    log "Script interrumpido por señal"
    exit 130
}

# Register signal handlers
trap cleanup SIGINT SIGTERM

#######################################
# Entry Point Guard
#
# Ensures main() is only called when script is executed directly,
# not when sourced by another script.
#######################################
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
